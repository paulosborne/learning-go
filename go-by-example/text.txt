pointers    - We'll show you how pointers work in contrast to valies with 2 functions: zeroval and zeroptr. zeroval has an int parameter, so arguments will be passed to it by valie. Zerval will get a copy of ival distinct from the one in the calling function. zeroptr in contrast has an *int parameter, meaning that it takes an int pointer. The *iptr code in the function body then dereferences the pointer from its memory address to the current value at that address. Assigning a value to a dereferenced pointer changes the value at the referenced address. The &i syntax gives the memory address of i, i.e a pointer to i. Pointers can be printed too. Zeroval doesnt change the i in main, but zeroptr does because it has a reference to the memory address for that variable.
structs     - GO's structs are typed collections of fields. They're useful for grouping data together to form records. This "person" struct type has a name and age fields. This syntax creates a new struct. You can name the fields when initializing a struct. Omitted fields will be zero-valued. A & yields a pointer to the struct. Access struct fields with a dot. You can also use dots with struct pointers - the pointers are automatically dereferenced. Structs are mutable.

mutable     - liable to change. Only applied to non-static, non-const data members of a class. Can be modified after it is created.
immutable   - an object whose state cannot be modified after it is created.

method      - Go supports methods defined on struct types. This area method has a receiver type of *rect Methods can be defined for either pointer of value receiver types. Here's an example of a value receiver. Methods can be defined for either pointer or value receiver types. Here's an example of a receiver value. Here we call 2 methods defined on our struct. Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receuver type to avoid copying on method calls or to allow the method to mutate the receiving struct.
interfaces  - Interfaces are named collections of method signatures. Heres a basic interface for geometric shapes. For our example we'll implement this interface on square and circle types.

